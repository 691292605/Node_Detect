import cv2
import numpy as np
from pdf2image import convert_from_path
from PIL import Image
import csv
import math

Image.MAX_IMAGE_PIXELS = None


# =========================================================
# 辅助函数
# =========================================================
def get_red_mask(img_hsv):
    lower_red1 = np.array([0, 43, 46])
    upper_red1 = np.array([10, 255, 255])
    lower_red2 = np.array([156, 43, 46])
    upper_red2 = np.array([180, 255, 255])
    mask1 = cv2.inRange(img_hsv, lower_red1, upper_red1)
    mask2 = cv2.inRange(img_hsv, lower_red2, upper_red2)
    return mask1 + mask2


def get_green_mask(img_hsv):
    # 【新增】绿色掩码 (覆盖虚线颜色)
    # Hue: 35-85 覆盖了大部分工程图的绿色
    lower_green = np.array([35, 43, 46])
    upper_green = np.array([85, 255, 255])
    return cv2.inRange(img_hsv, lower_green, upper_green)


def get_black_mask(img_hsv):
    lower_black = np.array([0, 0, 0])
    upper_black = np.array([180, 255, 120])
    return cv2.inRange(img_hsv, lower_black, upper_black)


# =========================================================
# 核心逻辑
# =========================================================
def analyze_and_scan_topology_v3(img_bgr, page_id):
    print(f"\n[处理进度] 正在分析第 {page_id} 页 (V3: 绿色虚线修复 + 强力横平竖直检测)...")

    hsv = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2HSV)
    vis_debug = img_bgr.copy()

    nodes = []
    forbidden_regions = []

    # =========================================================
    # PART 1: 节点识别 (V2 逻辑保持不变)
    # =========================================================

    # 1.1 红色框
    red_mask = get_red_mask(hsv)
    kernel_small = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
    red_mask_clean = cv2.dilate(red_mask, kernel_small, iterations=1)
    contours_red, _ = cv2.findContours(red_mask_clean, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for cnt in contours_red:
        area = cv2.contourArea(cnt)
        x, y, w, h = cv2.boundingRect(cnt)
        aspect_ratio = float(w) / h
        if area > 150 and 0.2 < aspect_ratio < 5.0 and area < 50000:
            M = cv2.moments(cnt)
            if M["m00"] != 0:
                cx = int(M["m10"] / M["m00"])
                cy = int(M["m01"] / M["m00"])
                nodes.append(
                    {"id": -1, "type": "red_box", "center": (cx, cy), "bbox": (x, y, w, h), "neighbors": set()})
                forbidden_regions.append((x, y, w, h))
                cv2.rectangle(vis_debug, (x, y), (x + w, y + h), (255, 0, 0), 2)

    # 1.2 黑色框
    black_mask_strict = get_black_mask(hsv)
    contours_black, _ = cv2.findContours(black_mask_strict, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for cnt in contours_black:
        area = cv2.contourArea(cnt)
        x, y, w, h = cv2.boundingRect(cnt)
        if 600 < area < 20000:
            aspect_ratio = float(w) / h
            if 0.5 < aspect_ratio < 2.5:
                M = cv2.moments(cnt)
                if M["m00"] != 0:
                    cx = int(M["m10"] / M["m00"])
                    cy = int(M["m01"] / M["m00"])
                    is_duplicate = False
                    for fx, fy, fw, fh in forbidden_regions:
                        if fx < cx < fx + fw and fy < cy < fy + fh:
                            is_duplicate = True
                            break
                    if not is_duplicate:
                        nodes.append({"id": -1, "type": "black_box", "center": (cx, cy), "bbox": (x, y, w, h),
                                      "neighbors": set()})
                        forbidden_regions.append((x, y, w, h))
                        cv2.rectangle(vis_debug, (x, y), (x + w, y + h), (0, 255, 255), 2)

    # 1.3 小圆点
    kernel_erode = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
    eroded_mask = cv2.erode(black_mask_strict, kernel_erode, iterations=1)
    dots_mask = cv2.dilate(eroded_mask, kernel_erode, iterations=3)
    contours_dots, _ = cv2.findContours(dots_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for cnt in contours_dots:
        area = cv2.contourArea(cnt)
        if 5 < area < 600:
            x, y, w, h = cv2.boundingRect(cnt)
            M = cv2.moments(cnt)
            if M["m00"] != 0:
                cx = int(M["m10"] / M["m00"])
                cy = int(M["m01"] / M["m00"])
                is_inside_box = False
                for fx, fy, fw, fh in forbidden_regions:
                    if (fx - 2) < cx < (fx + fw + 2) and (fy - 2) < cy < (fy + fh + 2):
                        is_inside_box = True
                        break
                if not is_inside_box:
                    perimeter = cv2.arcLength(cnt, True)
                    if perimeter == 0: continue
                    circularity = 4 * np.pi * (area / (perimeter * perimeter))
                    aspect_ratio = float(w) / h
                    if 0.5 < aspect_ratio < 2.0 and circularity > 0.6:
                        nodes.append(
                            {"id": -1, "type": "dot", "center": (cx, cy), "bbox": (x, y, w, h), "neighbors": set()})
                        cv2.rectangle(vis_debug, (x, y), (x + w, y + h), (0, 255, 0), 2)

    cv2.imwrite(f"debug_{page_id}_v3_nodes.jpg", vis_debug)
    nodes.sort(key=lambda n: n['center'][1])
    for idx, node in enumerate(nodes):
        node['id'] = idx

    # =========================================================
    # PART 2: 连线逻辑 (V3 重点修改：虚线修复)
    # =========================================================

    # 2.1 准备线路掩码
    lower_gray = np.array([0, 0, 0])
    upper_gray = np.array([180, 50, 200])
    mask_structure = cv2.inRange(hsv, lower_gray, upper_gray)  # 黑色/灰色线
    green_mask = get_green_mask(hsv)  # 绿色线

    # 【关键修改 1】合并绿色和结构线
    mask_lines = cv2.bitwise_or(mask_structure, red_mask)
    mask_lines = cv2.bitwise_or(mask_lines, green_mask)  # 加入绿色！

    # 填充节点区域 (保持通路)
    for node in nodes:
        x, y, w, h = node['bbox']
        cv2.rectangle(mask_lines, (x, y), (x + w, y + h), 255, -1)

    # 【关键修改 2】强力闭运算修复虚线
    # 分别做横向和纵向的闭运算，把断开的虚线连起来
    # 横向核：(15, 1) -> 连横虚线
    kernel_hori = cv2.getStructuringElement(cv2.MORPH_RECT, (15, 1))
    mask_hori = cv2.morphologyEx(mask_lines, cv2.MORPH_CLOSE, kernel_hori)

    # 纵向核：(1, 15) -> 连竖虚线
    kernel_vert = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 15))
    mask_vert = cv2.morphologyEx(mask_lines, cv2.MORPH_CLOSE, kernel_vert)

    # 合并修复后的结果
    mask_lines = cv2.bitwise_or(mask_hori, mask_vert)

    # 最后的膨胀，确保线够粗
    kernel_dilate = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
    mask_lines = cv2.dilate(mask_lines, kernel_dilate, iterations=1)

    cv2.imwrite(f"debug_{page_id}_v3_scan_mask.jpg", mask_lines)

    # 2.2 像素路径检测 (升级版 V3)
    def check_pixel_path_v3(p1, p2, mask):
        dx = p1[0] - p2[0]
        dy = p1[1] - p2[1]

        # 判断是否横平竖直 (允许 5 度误差)
        angle_deg = math.degrees(math.atan2(abs(dy), abs(dx)))
        is_horizontal = angle_deg < 5
        is_vertical = angle_deg > 85

        # 既然你说虚线肯定是横平竖直的，我们针对这种情况做特判
        if is_horizontal or is_vertical:
            # 采样
            dist = math.hypot(dx, dy)
            if dist < 1: return True
            steps = int(dist)
            if steps == 0: return True

            x_values = np.linspace(p1[0], p2[0], steps).astype(int)
            y_values = np.linspace(p1[1], p2[1], steps).astype(int)

            h, w = mask.shape
            valid = (x_values >= 0) & (x_values < w) & (y_values >= 0) & (y_values < h)
            x_values = x_values[valid]
            y_values = y_values[valid]
            if len(x_values) == 0: return False

            path_pixels = mask[y_values, x_values]
            non_zero = cv2.countNonZero(path_pixels)
            ratio = non_zero / len(path_pixels)

            # 【关键修改 3】对于横平竖直的线，大幅降低阈值
            # 即使修复了掩码，虚线可能还是有点断断续续，只要 40% 是白的就算通
            return ratio > 0.90

        else:
            # 斜线依然保持严格逻辑
            dist = math.hypot(dx, dy)
            if dist < 1: return True
            steps = int(dist)
            if steps == 0: return True
            x_values = np.linspace(p1[0], p2[0], steps).astype(int)
            y_values = np.linspace(p1[1], p2[1], steps).astype(int)
            h, w = mask.shape
            valid = (x_values >= 0) & (x_values < w) & (y_values >= 0) & (y_values < h)
            x_values = x_values[valid]
            y_values = y_values[valid]
            if len(x_values) == 0: return False
            path_pixels = mask[y_values, x_values]
            non_zero = cv2.countNonZero(path_pixels)
            ratio = non_zero / len(path_pixels)

            # 检查最大连续黑点 (Gap Check)
            max_zeros = 0
            curr_zeros = 0
            for px in path_pixels:
                if px == 0:
                    curr_zeros += 1
                else:
                    max_zeros = max(max_zeros, curr_zeros)
                    curr_zeros = 0
            max_zeros = max(max_zeros, curr_zeros)

            if max_zeros > 12: return False
            return ratio > 0.90

    # 2.3 主循环
    vis_final = img_bgr.copy()

    for i, node_A in enumerate(nodes):
        pos_A = node_A['center']
        candidates = []
        for j, node_B in enumerate(nodes):
            if i == j: continue
            dx = node_B['center'][0] - pos_A[0]
            dy = node_B['center'][1] - pos_A[1]
            dist = math.hypot(dx, dy)
            if dist < 800:
                angle = math.atan2(dy, dx)
                candidates.append({"node": node_B, "dist": dist, "angle": angle})

        candidates.sort(key=lambda x: x['dist'])

        accepted_angles = []
        for cand in candidates:
            node_B = cand['node']
            curr_angle = cand['angle']

            # 同向遮挡
            is_blocked_direction = False
            for theta in accepted_angles:
                diff = abs(curr_angle - theta)
                if diff > math.pi: diff = 2 * math.pi - diff
                if diff < 0.35:
                    is_blocked_direction = True
                    break

            if is_blocked_direction: continue

            if check_pixel_path_v3(pos_A, node_B['center'], mask_lines):
                node_A['neighbors'].add(node_B['id'])
                accepted_angles.append(curr_angle)
                cv2.line(vis_final, pos_A, node_B['center'], (0, 255, 0), 2)

    # 绘制结果
    for node in nodes:
        color = (0, 255, 0)
        # 检查是否孤立
        if len(node['neighbors']) == 0:
            cv2.circle(vis_final, node['center'], 10, (0, 0, 255), 2)

        if node['type'] == 'red_box': color = (255, 0, 0)
        if node['type'] == 'black_box': color = (0, 255, 255)
        cv2.circle(vis_final, node['center'], 5, color, -1)
        cv2.putText(vis_final, str(node['id']), (node['center'][0], node['center'][1] - 10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.4, color, 1)

    cv2.imwrite(f"result_page_{page_id}_v3.jpg", vis_final)

    nodes.sort(key=lambda n: n['id'])
    output = []
    for n in nodes:
        output.append({
            "page": page_id, "id": n['id'], "type": n['type'],
            "pos": n['center'], "neighbors": sorted(list(n['neighbors']))
        })
    return output


def save_to_csv_v3(all_data, filename="topology_results_v3.csv"):
    print(f"\n正在保存数据到 {filename} ...")
    with open(filename, mode='w', newline='', encoding='utf-8-sig') as csv_file:
        fieldnames = ['Node_ID', 'Type', 'Pos_X', 'Pos_Y', 'Neighbors']
        writer = csv.DictWriter(csv_file, fieldnames=fieldnames)
        writer.writeheader()
        count = 0
        for page_data in all_data:
            for node in page_data:
                neighbors_str = ";".join(map(str, node['neighbors']))
                writer.writerow({
                    'Node_ID': node['id'],
                    'Type': node['type'],
                    'Pos_X': node['pos'][0],
                    'Pos_Y': node['pos'][1],
                    'Neighbors': neighbors_str
                })
                count += 1
    print(f"保存完成。共 {count} 条记录。")


def process_pdf(pdf_path, poppler_path, password):
    print(f"正在读取 PDF: {pdf_path}")
    images = convert_from_path(pdf_path, dpi=200, poppler_path=poppler_path, userpw=password)
    all_pages_data = []
    for i, pil_img in enumerate(images):
        img_np = np.array(pil_img)
        if len(img_np.shape) == 3:
            img_cv = cv2.cvtColor(img_np, cv2.COLOR_RGB2BGR)
        else:
            img_cv = cv2.cvtColor(img_np, cv2.COLOR_GRAY2BGR)

        # 调用 v3 函数
        page_results = analyze_and_scan_topology_v3(img_cv, page_id=i + 1)
        all_pages_data.append(page_results)

    # 调用 v3 保存函数
    save_to_csv_v3(all_pages_data)


if __name__ == "__main__":
    # 请修改这里的路径
    #my_pdf = r"C:\Users\69129\Desktop\python space\pythonProject1\dian\picture\767ce3f95546d1e3c0dbad925bc4b5ac_3bc5441cbd9497a620aa5f8a912d630d_8.pdf"
    my_pdf = r"C:\Users\69129\Desktop\python space\pythonProject1\dian\picture\138e68df2d6a8f47093efd4598912f4d_cf53f7b9ab7080425636e9c239100df0_8.pdf"
    #my_pdf = r"C:\Users\69129\Desktop\python space\pythonProject1\dian\picture\0aff7daebb20ca860422a631cefc8613_24fc8778dad47e8dfb3f5e8ac385ff83_8.pdf"
    my_poppler = r"C:\Users\69129\Desktop\python space\pythonProject1\dian\poppler-25.12.0\Library\bin"
    my_password = "Dian123456"
    process_pdf(my_pdf, my_poppler, my_password)
