import csv  # 新增: 用于CSV操作
import cv2
import numpy as np
from PIL import Image
from pdf2image import convert_from_path

# 解除 PIL 的大像素限制
Image.MAX_IMAGE_PIXELS = None


def analyze_and_scan_topology(img_bgr, page_id):
    print(f"\n[处理进度] 正在分析第 {page_id} 页...")

    # =========================================================
    # 阶段一：高精度节点识别 (腐蚀分离法)
    # =========================================================

    # 1. 颜色提取：只认“纯黑”
    hsv = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2HSV)
    lower_black = np.array([0, 0, 0])
    upper_black = np.array([180, 255, 90])
    original_mask = cv2.inRange(hsv, lower_black, upper_black)

    # 调试图 1 (可选)
    # cv2.imwrite(f"debug_{page_id}_1_original_mask.jpg", original_mask)

    # 2. 形态学处理：腐蚀 (分离节点和线)
    # [参数保持您调试好的最佳值]
    kernel_erode = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))

    # 腐蚀: 这里的 iterations 根据之前的调试结果设定 (通常 1 或 2)
    eroded_mask = cv2.erode(original_mask, kernel_erode, iterations=1)

    # 膨胀: 恢复节点大小
    node_detection_mask = cv2.dilate(eroded_mask, kernel_erode, iterations=3)

    # 调试图 2 (可选)
    # cv2.imwrite(f"debug_{page_id}_2_node_separated.jpg", node_detection_mask)

    # 3. 轮廓筛选
    contours, _ = cv2.findContours(node_detection_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    nodes = []
    lines_scan_mask = original_mask.copy()

    for cnt in contours:
        area = cv2.contourArea(cnt)

        # [参数保持不变] 面积 10~800
        if 10 < area < 800:
            x, y, w, h = cv2.boundingRect(cnt)
            aspect_ratio = float(w) / h
            perimeter = cv2.arcLength(cnt, True)
            if perimeter == 0: continue
            circularity = 4 * np.pi * (area / (perimeter * perimeter))

            # [参数保持不变] 形状筛选
            if 0.5 < aspect_ratio < 2.0 and circularity > 0.6:
                M = cv2.moments(cnt)
                if M["m00"] != 0:
                    cx = int(M["m10"] / M["m00"])
                    cy = int(M["m01"] / M["m00"])

                    nodes.append({
                        "id": len(nodes),  # 临时ID，稍后会排序重置
                        "center": (cx, cy),
                        "neighbors": set()
                    })

                    # 挖空节点位置，防止扫描干扰
                    cv2.rectangle(lines_scan_mask, (x - 3, y - 3), (x + w + 3, y + h + 3), 0, -1)

    print(f"  -> 第 {page_id} 页检测到 {len(nodes)} 个节点")

    # =========================================================
    # 阶段二：几何扫描 (只找相邻节点)
    # =========================================================

    vis_final_result = img_bgr.copy()
    SCAN_TOLERANCE = 8

    def check_connection(p1, p2, mask):
        x1, y1 = p1
        x2, y2 = p2
        # 提取 ROI
        if abs(x1 - x2) > abs(y1 - y2):  # 横向
            p_start, p_end = min(x1, x2) + 6, max(x1, x2) - 6
            q_start, q_end = min(y1, y2) - 3, max(y1, y2) + 3
            roi = mask[q_start:q_end, p_start:p_end]
        else:  # 纵向
            p_start, p_end = min(x1, x2) - 3, max(x1, x2) + 3
            q_start, q_end = min(y1, y2) + 6, max(y1, y2) - 6
            roi = mask[q_start:q_end, p_start:p_end]

        if roi.size == 0: return False
        white_pixels = cv2.countNonZero(roi)
        return (white_pixels / roi.size) > 0.08

    # --- A. 横向扫描 ---
    nodes.sort(key=lambda n: n['center'][1])
    current_row = [nodes[0]] if nodes else []

    for i in range(1, len(nodes)):
        curr = nodes[i]
        prev = current_row[-1]
        if abs(curr['center'][1] - prev['center'][1]) < SCAN_TOLERANCE:
            current_row.append(curr)
        else:
            current_row.sort(key=lambda n: n['center'][0])
            for j in range(len(current_row) - 1):
                n1, n2 = current_row[j], current_row[j + 1]
                if check_connection(n1['center'], n2['center'], lines_scan_mask):
                    n1['neighbors'].add(n2['id'])
                    n2['neighbors'].add(n1['id'])
                    cv2.line(vis_final_result, n1['center'], n2['center'], (0, 255, 0), 2)
            current_row = [curr]
    if current_row:  # 扫尾
        current_row.sort(key=lambda n: n['center'][0])
        for j in range(len(current_row) - 1):
            n1, n2 = current_row[j], current_row[j + 1]
            if check_connection(n1['center'], n2['center'], lines_scan_mask):
                n1['neighbors'].add(n2['id'])
                n2['neighbors'].add(n1['id'])
                cv2.line(vis_final_result, n1['center'], n2['center'], (0, 255, 0), 2)

    # --- B. 纵向扫描 ---
    nodes.sort(key=lambda n: n['center'][0])
    current_col = [nodes[0]] if nodes else []

    for i in range(1, len(nodes)):
        curr = nodes[i]
        prev = current_col[-1]
        if abs(curr['center'][0] - prev['center'][0]) < SCAN_TOLERANCE:
            current_col.append(curr)
        else:
            current_col.sort(key=lambda n: n['center'][1])
            for j in range(len(current_col) - 1):
                n1, n2 = current_col[j], current_col[j + 1]
                if check_connection(n1['center'], n2['center'], lines_scan_mask):
                    n1['neighbors'].add(n2['id'])
                    n2['neighbors'].add(n1['id'])
                    cv2.line(vis_final_result, n1['center'], n2['center'], (0, 255, 0), 2)
            current_col = [curr]
    if current_col:  # 扫尾
        current_col.sort(key=lambda n: n['center'][1])
        for j in range(len(current_col) - 1):
            n1, n2 = current_col[j], current_col[j + 1]
            if check_connection(n1['center'], n2['center'], lines_scan_mask):
                n1['neighbors'].add(n2['id'])
                n2['neighbors'].add(n1['id'])
                cv2.line(vis_final_result, n1['center'], n2['center'], (0, 255, 0), 2)

    # 保存最终可视化结果（依然保留图片输出以便核对）
    for node in nodes:
        cv2.circle(vis_final_result, node['center'], 4, (0, 0, 255), -1)
    cv2.imwrite(f"result_page_{page_id}.jpg", vis_final_result)

    # 整理数据返回
    # 按照 ID 重新排序，确保 CSV 里的 ID 是有序的
    nodes.sort(key=lambda n: n['id'])

    output = []
    for n in nodes:
        output.append({
            "page": page_id,
            "id": n['id'],
            "pos": n['center'],
            "neighbors": sorted(list(n['neighbors']))
        })
    return output


def save_to_csv(all_data, filename="topology_results.csv"):
    """
    将所有页面的数据保存为 CSV 文件
    格式: Page, Node_ID, Pos_X, Pos_Y, Neighbors
    """
    print(f"\n正在保存数据到 {filename} ...")

    with open(filename, mode='w', newline='', encoding='utf-8-sig') as csv_file:
        fieldnames = ['Page', 'Node_ID', 'Pos_X', 'Pos_Y', 'Neighbors']
        writer = csv.DictWriter(csv_file, fieldnames=fieldnames)

        writer.writeheader()

        count = 0
        for page_data in all_data:
            for node in page_data:
                # 把列表 [1, 5] 转换成字符串 "1;5" 方便 Excel 查看
                neighbors_str = ";".join(map(str, node['neighbors']))

                writer.writerow({
                    'Page': node['page'],
                    'Node_ID': node['id'],
                    'Pos_X': node['pos'][0],
                    'Pos_Y': node['pos'][1],
                    'Neighbors': neighbors_str
                })
                count += 1

    print(f"保存完成！共写入 {count} 个节点数据。")


def process_pdf(pdf_path, poppler_path, password):
    print(f"正在读取 PDF: {pdf_path}")
    images = convert_from_path(pdf_path, dpi=250, poppler_path=poppler_path, userpw=password)

    all_pages_data = []  # 用于收集所有页面的结果

    for i, pil_img in enumerate(images):
        img_np = np.array(pil_img)
        if len(img_np.shape) == 3:
            img_cv = cv2.cvtColor(img_np, cv2.COLOR_RGB2BGR)
        else:
            img_cv = cv2.cvtColor(img_np, cv2.COLOR_GRAY2BGR)

        # 处理单页
        page_results = analyze_and_scan_topology(img_cv, page_id=i + 1)
        all_pages_data.append(page_results)

    # 所有页面处理完毕，保存 CSV
    save_to_csv(all_pages_data)


if __name__ == "__main__":
    # ==========================================
    # 请在此处替换您的路径
    # ==========================================
    my_pdf = r"C:\Users\69129\Desktop\python space\pythonProject1\dian\picture\138e68df2d6a8f47093efd4598912f4d_cf53f7b9ab7080425636e9c239100df0_8.pdf"
    my_poppler = r"C:\Users\69129\Desktop\python space\pythonProject1\dian\poppler-25.12.0\Library\bin"
    my_password = "Dian123456"

    process_pdf(my_pdf, my_poppler, my_password)
