import cv2
import numpy as np
from pdf2image import convert_from_path
from PIL import Image
import csv
import math

Image.MAX_IMAGE_PIXELS = None


# =========================================================
# 辅助函数
# =========================================================
def get_red_mask(img_hsv):
    lower_red1 = np.array([0, 43, 46])
    upper_red1 = np.array([10, 255, 255])
    lower_red2 = np.array([156, 43, 46])
    upper_red2 = np.array([180, 255, 255])
    mask1 = cv2.inRange(img_hsv, lower_red1, upper_red1)
    mask2 = cv2.inRange(img_hsv, lower_red2, upper_red2)
    return mask1 + mask2


def get_black_mask(img_hsv):
    lower_black = np.array([0, 0, 0])
    upper_black = np.array([180, 255, 120])
    return cv2.inRange(img_hsv, lower_black, upper_black)


# =========================================================
# 核心逻辑
# =========================================================
def analyze_and_scan_topology_v2(img_bgr, page_id):
    # 将原来的 V8 提示改为 V2
    print(f"\n[处理进度] 正在分析第 {page_id} 页 (V2: 细线增强+孤立节点救援)...")

    hsv = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2HSV)
    vis_debug = img_bgr.copy()

    nodes = []
    forbidden_regions = []

    # =========================================================
    # PART 1: 节点识别 (保持不变)
    # =========================================================

    # 1.1 红色框
    red_mask = get_red_mask(hsv)
    kernel_small = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
    red_mask_clean = cv2.dilate(red_mask, kernel_small, iterations=1)
    contours_red, _ = cv2.findContours(red_mask_clean, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for cnt in contours_red:
        area = cv2.contourArea(cnt)
        x, y, w, h = cv2.boundingRect(cnt)
        aspect_ratio = float(w) / h
        if area > 150 and 0.2 < aspect_ratio < 5.0 and area < 50000:
            M = cv2.moments(cnt)
            if M["m00"] != 0:
                cx = int(M["m10"] / M["m00"])
                cy = int(M["m01"] / M["m00"])
                nodes.append(
                    {"id": -1, "type": "red_box", "center": (cx, cy), "bbox": (x, y, w, h), "neighbors": set()})
                forbidden_regions.append((x, y, w, h))
                cv2.rectangle(vis_debug, (x, y), (x + w, y + h), (255, 0, 0), 2)

    # 1.2 黑色框
    black_mask_strict = get_black_mask(hsv)
    contours_black, _ = cv2.findContours(black_mask_strict, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for cnt in contours_black:
        area = cv2.contourArea(cnt)
        x, y, w, h = cv2.boundingRect(cnt)
        if 600 < area < 20000:
            aspect_ratio = float(w) / h
            if 0.5 < aspect_ratio < 2.5:
                M = cv2.moments(cnt)
                if M["m00"] != 0:
                    cx = int(M["m10"] / M["m00"])
                    cy = int(M["m01"] / M["m00"])
                    is_duplicate = False
                    for fx, fy, fw, fh in forbidden_regions:
                        if fx < cx < fx + fw and fy < cy < fy + fh:
                            is_duplicate = True
                            break
                    if not is_duplicate:
                        nodes.append({"id": -1, "type": "black_box", "center": (cx, cy), "bbox": (x, y, w, h),
                                      "neighbors": set()})
                        forbidden_regions.append((x, y, w, h))
                        cv2.rectangle(vis_debug, (x, y), (x + w, y + h), (0, 255, 255), 2)

    # 1.3 小圆点
    kernel_erode = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
    eroded_mask = cv2.erode(black_mask_strict, kernel_erode, iterations=1)
    dots_mask = cv2.dilate(eroded_mask, kernel_erode, iterations=3)
    contours_dots, _ = cv2.findContours(dots_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for cnt in contours_dots:
        area = cv2.contourArea(cnt)
        if 5 < area < 600:
            x, y, w, h = cv2.boundingRect(cnt)
            M = cv2.moments(cnt)
            if M["m00"] != 0:
                cx = int(M["m10"] / M["m00"])
                cy = int(M["m01"] / M["m00"])
                is_inside_box = False
                for fx, fy, fw, fh in forbidden_regions:
                    if (fx - 2) < cx < (fx + fw + 2) and (fy - 2) < cy < (fy + fh + 2):
                        is_inside_box = True
                        break
                if not is_inside_box:
                    perimeter = cv2.arcLength(cnt, True)
                    if perimeter == 0: continue
                    circularity = 4 * np.pi * (area / (perimeter * perimeter))
                    aspect_ratio = float(w) / h
                    if 0.5 < aspect_ratio < 2.0 and circularity > 0.6:
                        nodes.append(
                            {"id": -1, "type": "dot", "center": (cx, cy), "bbox": (x, y, w, h), "neighbors": set()})
                        cv2.rectangle(vis_debug, (x, y), (x + w, y + h), (0, 255, 0), 2)

    # cv2.imwrite(f"debug_{page_id}_v2_nodes.jpg", vis_debug) # 这里的 v8 改 v2
    nodes.sort(key=lambda n: n['center'][1])
    for idx, node in enumerate(nodes):
        node['id'] = idx

    # =========================================================
    # PART 2: 连线逻辑 (V2 改进版)
    # =========================================================

    # 2.1 准备更敏感的线路掩码 (Structure Mask)
    lower_gray = np.array([0, 0, 0])
    upper_gray = np.array([180, 50, 200])
    mask_structure = cv2.inRange(hsv, lower_gray, upper_gray)

    # 合并红色和新的结构掩码
    mask_lines = cv2.bitwise_or(mask_structure, red_mask)

    # 填充节点区域
    for node in nodes:
        x, y, w, h = node['bbox']
        cv2.rectangle(mask_lines, (x, y), (x + w, y + h), 255, -1)

    # 使用闭运算(Closing)修复断裂，再膨胀
    kernel_line = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
    mask_lines = cv2.morphologyEx(mask_lines, cv2.MORPH_CLOSE, kernel_line)
    mask_lines = cv2.dilate(mask_lines, kernel_line, iterations=1)

    # cv2.imwrite(f"debug_{page_id}_v2_scan_mask.jpg", mask_lines) # 这里的 v8 改 v2

    # 2.2 像素路径检测
    def check_pixel_path_v3(p1, p2, mask):
        dx = p1[0] - p2[0]
        dy = p1[1] - p2[1]
        dist = math.hypot(dx, dy)
        if dist < 1: return True
        steps = int(dist)
        if steps == 0: return True

        x_values = np.linspace(p1[0], p2[0], steps).astype(int)
        y_values = np.linspace(p1[1], p2[1], steps).astype(int)
        h, w = mask.shape
        valid = (x_values >= 0) & (x_values < w) & (y_values >= 0) & (y_values < h)
        x_values = x_values[valid]
        y_values = y_values[valid]
        if len(x_values) == 0: return False

        path_pixels = mask[y_values, x_values]

        # 1. 连续黑点检测 (Gap Check)
        max_consecutive_zeros = 0
        current_zeros = 0
        for px in path_pixels:
            if px == 0:
                current_zeros += 1
            else:
                if current_zeros > max_consecutive_zeros: max_consecutive_zeros = current_zeros
                current_zeros = 0
        if current_zeros > max_consecutive_zeros: max_consecutive_zeros = current_zeros

        # 2. 角度判断
        angle_rad = abs(math.atan2(dy, dx))
        angle_deg = math.degrees(angle_rad) % 180
        if angle_deg > 90: angle_deg = 180 - angle_deg
        is_manhattan = (angle_deg < 8) or (angle_deg > 82)

        non_zero = cv2.countNonZero(path_pixels)
        ratio = non_zero / len(path_pixels)

        # 3. 针对直线放宽标准
        if is_manhattan:
            if max_consecutive_zeros > 20: return False
            return ratio > 0.45
        else:
            if max_consecutive_zeros > 12: return False
            return ratio > 0.80

    # 2.3 主循环
    vis_final = img_bgr.copy()

    for i, node_A in enumerate(nodes):
        pos_A = node_A['center']
        candidates = []
        for j, node_B in enumerate(nodes):
            if i == j: continue
            dx = node_B['center'][0] - pos_A[0]
            dy = node_B['center'][1] - pos_A[1]
            dist = math.hypot(dx, dy)
            if dist < 800:
                angle = math.atan2(dy, dx)
                candidates.append({"node": node_B, "dist": dist, "angle": angle})

        candidates.sort(key=lambda x: x['dist'])

        accepted_angles = []
        for cand in candidates:
            node_B = cand['node']
            curr_angle = cand['angle']

            # 同向遮挡
            is_blocked_direction = False
            for theta in accepted_angles:
                diff = abs(curr_angle - theta)
                if diff > math.pi: diff = 2 * math.pi - diff
                if diff < 0.35:
                    is_blocked_direction = True
                    break

            if is_blocked_direction: continue

            if check_pixel_path_v3(pos_A, node_B['center'], mask_lines):
                node_A['neighbors'].add(node_B['id'])
                accepted_angles.append(curr_angle)
                cv2.line(vis_final, pos_A, node_B['center'], (0, 255, 0), 2)

    # 绘制结果
    for node in nodes:
        color = (0, 255, 0)
        # 检查是否孤立
        if len(node['neighbors']) == 0:
            cv2.circle(vis_final, node['center'], 10, (0, 0, 255), 2)

        if node['type'] == 'red_box': color = (255, 0, 0)
        if node['type'] == 'black_box': color = (0, 255, 255)
        cv2.circle(vis_final, node['center'], 5, color, -1)
        cv2.putText(vis_final, str(node['id']), (node['center'][0], node['center'][1] - 10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.4, color, 1)

    # 输出结果图改为 v2
    cv2.imwrite(f"result_page_{page_id}_v2.jpg", vis_final)

    nodes.sort(key=lambda n: n['id'])
    output = []
    for n in nodes:
        output.append({
            "page": page_id, "id": n['id'], "type": n['type'],
            "pos": n['center'], "neighbors": sorted(list(n['neighbors']))
        })
    return output


def save_to_csv_v2(all_data, filename="topology_results_v2.csv"):
    print(f"\n正在保存数据到 {filename} ...")
    with open(filename, mode='w', newline='', encoding='utf-8-sig') as csv_file:
        fieldnames = ['Node_ID', 'Type', 'Pos_X', 'Pos_Y', 'Neighbors']
        writer = csv.DictWriter(csv_file, fieldnames=fieldnames)
        writer.writeheader()
        count = 0
        for page_data in all_data:
            for node in page_data:
                neighbors_str = ";".join(map(str, node['neighbors']))
                writer.writerow({
                    'Node_ID': node['id'],
                    'Type': node['type'],
                    'Pos_X': node['pos'][0],
                    'Pos_Y': node['pos'][1],
                    'Neighbors': neighbors_str
                })
                count += 1
    print(f"保存完成。共 {count} 条记录。")


def process_pdf(pdf_path, poppler_path, password):
    print(f"正在读取 PDF: {pdf_path}")
    images = convert_from_path(pdf_path, dpi=250, poppler_path=poppler_path, userpw=password)
    all_pages_data = []
    for i, pil_img in enumerate(images):
        img_np = np.array(pil_img)
        if len(img_np.shape) == 3:
            img_cv = cv2.cvtColor(img_np, cv2.COLOR_RGB2BGR)
        else:
            img_cv = cv2.cvtColor(img_np, cv2.COLOR_GRAY2BGR)

        # 调用 v2 函数
        page_results = analyze_and_scan_topology_v2(img_cv, page_id=i + 1)
        all_pages_data.append(page_results)

    # 调用 v2 保存函数
    save_to_csv_v2(all_pages_data)


if __name__ == "__main__":
    my_pdf = r"C:\Users\69129\Desktop\python space\pythonProject1\dian\picture\138e68df2d6a8f47093efd4598912f4d_cf53f7b9ab7080425636e9c239100df0_8.pdf"
    my_poppler = r"C:\Users\69129\Desktop\python space\pythonProject1\dian\poppler-25.12.0\Library\bin"
    my_password = "Dian123456"
    process_pdf(my_pdf, my_poppler, my_password)
